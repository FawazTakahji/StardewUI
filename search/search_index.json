{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Stardew UI","text":"<p>A convenient, fast and scalable UI framework for Stardew Valley mods, dedicated to making UI development a breeze rather than a chore. Inspired in part by Angular and XAML.</p> <ul> <li> <p> StardewUI Core is an includable code library in the form of a .NET Shared Project, containing the layout and rendering services, fundamental widgets, and integrations with the Stardew Valley base game, in particular its Menu system.</p> </li> <li> <p> StardewUI Framework is a standalone mod that hosts its own version of the Core library and provides a Model-View-Whatever (MVW) binding system using StarML as well as many other quality-of-life features not found in the Core.</p> </li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li> <p> Dynamic layout</p> <p>Don't fuss with pixel positions; design with flows, grids and other layouts that adapt to your content.</p> <p> Built-in layouts</p> </li> <li> <p> High performance</p> <p>Retained-mode UI only updates the things that change, when they change. Your UI will never stutter, even on potatoes.</p> <p> Details and benchmarks</p> </li> <li> <p> Controller ready</p> <p>No fussy neighbor lists, clunky clickable components or other boilerplate. Mouse or gamepad,  it just works.</p> <p> Focus and interaction</p> </li> <li> <p> Model-View-Whatever</p> <p>Keep your views and data separate, using an enhanced HTML-like markup with data binding and hot reload.</p> <p> StarML guide</p> </li> <li> <p> Don't reinvent the wheel</p> <p>Pre-made widgets cover everything from simple text and images to drop-down lists, sliders, input boxes and scrollbars.</p> <p> Standard views</p> </li> <li> <p> Made for modding</p> <p>Designed for SMAPI. StarML documents are normal game assets, and can be edited or replaced without Harmony patching.</p> <p> All about assets</p> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>In this introductory example, we'll be using the Framework, which is recommended if you're new to StardewUI. You'll need to be familiar with basic C# modding.</p> <p>Try it out</p> <p>Want to see the complete working example in game? The full source can be found in the test mod. Install it along with StardewUI and press F9 after loading a save.</p> ModEntry.csMenuData.csScrollingItemGrid.sml <pre><code>internal sealed class ModEntry : Mod\n{\n    private IViewEngine viewEngine;\n\n    public override void Entry(IModHelper helper)\n    {\n        helper.Events.GameLoop.GameLaunched += GameLoop_GameLaunched;\n        helper.Events.Input.ButtonPressed += Input_ButtonPressed;\n    }\n\n    private void GameLoop_GameLaunched(object? sender, GameLaunchedEventArgs e)\n    {\n        viewEngine = Helper.ModRegistry.GetApi&lt;IViewEngine&gt;(\"focustense.StardewUI\");\n        viewEngine.RegisterViews(\"Mods/TestMod/Views\", \"assets/views\");\n        viewEngine.EnableHotReloading();\n    }\n\n    private void Input_ButtonPressed(object? sender, ButtonPressedEventArgs e)\n    {\n        if (Context.IsPlayerFree &amp;&amp; e.Button == SButton.F8)\n        {\n            var context = MenuData.Edibles();\n            Game1.activeClickableMenu = viewEngine.CreateMenuFromAsset(\n                \"Mods/TestMod/Views/ScrollingItemGrid\",\n                context);\n        }\n    }\n}\n</code></pre> <pre><code>public class MenuData\n{\n    public string HeaderText { get; set; } = \"\";\n    public List&lt;ParsedItemData&gt; Items { get; set; } = [];\n\n    public static MenuData Edibles()\n    {\n        int[] edibleCategories = [\n            StardewValley.Object.CookingCategory,\n            StardewValley.Object.EggCategory,\n            StardewValley.Object.FishCategory,\n            StardewValley.Object.FruitsCategory,\n            StardewValley.Object.meatCategory,\n            StardewValley.Object.MilkCategory,\n            StardewValley.Object.VegetableCategory,\n        ];\n        var items = ItemRegistry.ItemTypes\n            .Single(type =&gt; type.Identifier == ItemRegistry.type_object)\n            .GetAllIds()\n            .Select(id =&gt; ItemRegistry.GetDataOrErrorItem(id))\n            .Where(data =&gt; edibleCategories.Contains(data.Category))\n            .ToList();\n        return new()\n        {\n            HeaderText = \"All Edibles\",\n            Items = items,\n        };\n    }\n}\n</code></pre> <pre><code>&lt;lane orientation=\"vertical\"\n      horizontal-content-alignment=\"middle\"&gt;\n    &lt;banner background={@Mods/StardewUI/Sprites/BannerBackground}\n            background-border-thickness=\"48,0\"\n            padding=\"12\"\n            text={HeaderText} /&gt;\n    &lt;frame layout=\"880px 640px\"\n           background={@Mods/StardewUI/Sprites/ControlBorder}\n           margin=\"0,16,0,0\"\n           padding=\"32,24\"&gt;\n        &lt;scrollable&gt;\n            &lt;grid layout=\"stretch content\"\n                  item-layout=\"length: 64\"\n                  item-spacing=\"16,16\"\n                  horizontal-item-alignment=\"middle\"&gt;\n                &lt;image layout=\"stretch content\"\n                       *repeat={Items}\n                       sprite={this}\n                       focusable=\"true\" /&gt;\n            &lt;/grid&gt;\n        &lt;/scrollable&gt;\n    &lt;/frame&gt;\n&lt;/lane&gt;\n</code></pre> <p>The result:</p> <p></p>"},{"location":"#next-steps","title":"Next Steps","text":"<p>To get started on your own UI, you can either browse the Examples or follow through the recommended reading order below:</p> <ol> <li>StarML: Features, rules, and a handy syntax reference.</li> <li>Concepts: Semi-technical shallow dive into the framework's underlying concepts and design. Learn what \"views\" and \"bindings\" are, and get the necessary background for troubleshooting bugs or performance problems.</li> <li>Binding Context: How to design a good data model for powering StarML views and menus, and make your UI responsive to changes in game/user state.</li> <li>Events: Eventually you'll probably want to make your UI do something, like interact with the game world or update some of your mod's state or setting. Event bindings are powerful enough to deserve their own page.</li> <li>Includes: As UIs grow in complexity, you'll often find yourself wanting to create reusable components to be used in many different menus, HUDs, etc. This tutorial goes over the process and potential pitfalls.</li> <li>The Core Library: How and when to use it; both the \"safe\" and \"unsafe\" ways.</li> <li>Custom Views: If the Framework doesn't have what you need, you can create your own, whether it's something simple like the <code>Banner</code> to an entirely new kind of layout.</li> <li>Framework Extensibility: Adding custom tags, conversions, attributes and more; most useful to those who have created one or more custom widgets and want to make them available in StarML.</li> </ol>"},{"location":"#happy-modding","title":"Happy Modding!","text":""},{"location":"concepts/","title":"Concepts","text":"<p>An extended introduction to StardewUI's major ideas and building blocks; this is a good place to start if you're coming from other UI frameworks (Qt, WPF/Avalonia, etc.) and wondering about the similarities and differences, or if you've never used a UI framework before and wondering why you can't\u2014or shouldn't\u2014simply do everything directly with <code>SpriteBatch</code> and <code>IClickableMenu</code> as is typical in Stardew.</p>"},{"location":"concepts/#views","title":"Views","text":"<p>These go by many different names in many different frameworks. In Qt and Flutter, they're widgets. In Windows Presentation Foundation, Windows Forms and Swift, they're controls. In Android and iOS, they are views. On the web, they are elements in pure HTML, and Angular or React might refer to them as components.</p> <p>Regardless of what we call them, and the many subtle differences between their behavior across frameworks and platforms, they always refer to the same basic concept: a self-contained, reusable object that controls its own appearance on screen and, sometimes, the user interactions it supports, such as clicks or hovers.</p> <p>StardewUI calls them Views, not because of any affinity with mobile frameworks, but because of the \"View\" in Model-View-Whatever (MVP, MVC, MVVM and so on). It may on occasion be referred to as a \"widget\" in other parts of documentation for clarity, or when discussing a view in terms of its behavior rather than what it technically is.</p>"},{"location":"concepts/#everything-is-a-view","title":"Everything is a view","text":"<p>Nothing useful happens in StardewUI without a View. Underneath it all is still MonoGame's <code>SpriteBatch</code>\u2014we do need a destination for those pixels\u2014but Views are what enable layout and reuse.</p> <p>Some views might seem very simple, even too trivial to be a view at all. Is a Label really anything more than a wrapper around <code>SpriteBatch.DrawString</code>, perhaps with a <code>Game1.parseText</code> thrown in?</p> <p>In a word, yes:</p> <ul> <li>What if we want to truncate/add an ellipsis after n lines?</li> <li>What if we want multiple lines to be horizontally centered, or even right-aligned?</li> <li>What if we want to simulate bold, or draw outlined or shadowed text?</li> </ul> <p>Text seems easy at first, but rarely stays that way. It's the same with images, which are all, in a sense, just <code>SpriteBatch.Draw</code> underneath; but is that all they are? What if the image isn't perfectly-sized for the area it needs to fit in - or if a single region needs to accommodate images of multiple sizes? Do we scale or stretch? Clip or crop? Can it be animated?</p> <p>The <code>SpriteBatch</code> is just a blank canvas on which to draw; views provide the reusability, interactivity, reactivity, and everything else we've come to expect from a user interface.</p>"},{"location":"concepts/#layout-views-and-view-trees","title":"Layout views and view trees","text":"<p>So far, we've only touched on basic view types like labels and images, but the real power of StardewUI is in its layout system which is based on layout views.</p> <p>A layout view isn't a specific type, or supertype; it describes any view that is responsible for laying out (positioning and sizing) at least one other view, with those other views being considered the children of the layout view. Together they form a tree:</p> <p>Example</p> <p></p> Lane: Menu Banner: Settings Frame: Border Label: Speed Lane: Row 1 Label: Enable turbo boost Checkbox Lane: Row 2 Label: Speed multiplier Slider <p>The structure is the same whether you're using the Core Library or StarML. At the end of the day, everything resolves to a pixel position, but you almost never deal with pixel positions directly; instead, you work with views (or elements, in StarML), and the layout views\u2014in the above example, the Frame and Lanes\u2014decide how to lay out their children\u2014in this case, the various Labels, Checkbox and Slider.</p>"},{"location":"concepts/#layout","title":"Layout","text":"<p>Many of the pages on this site refer to layout, but what actually is layout?</p> <p>Microsoft's definition is useful here:</p> <p>At its simplest, layout is a recursive system that leads to an element being sized, positioned, and drawn. More specifically, layout describes the process of measuring and arranging the members of a [Layout View] element's <code>Children</code> collection.</p> <p>The original definition refers to a \"Panel\"; the equivalent concept in StardewUI is a \"layout view\".</p> <p>Much like Microsoft's WPF \u2013 and Android, and Apple's UIKit, and the majority of UI frameworks \u2013 StardewUI layout is completed in two recursive passes:</p> <ol> <li>The Measure Pass, in which children (which may themselves be layout views) are assigned sizes based on (a) the amount of available space, or limits, and (b) the amount of space they want, which could be based on the limits, or be a fixed size, or be a function of the content, or multiple or none of the above. The important thing is that each view is told how much space, horizontal and vertical, that it is allowed to use, and then reports back how much it will use.</li> <li>The Layout Pass, in which all the size measurements are combined in order to determine the pixel positions (relative to the parent) of each view. Sometimes this might just mean stacking left-to-right or top-to-bottom, e.g. in a <code>Lane</code> but for other layout types it could involve alignments, wrapping, clipping, offsetting, or doing nothing at all (e.g. drawing its children/content in place at position <code>(0, 0)</code>).</li> </ol> <p>These passes are somewhat implicit in StardewUI\u2014there are not separate methods named \"measure\" and \"layout\". However, it is how every layout view works inside its <code>Measure</code> method.</p> <p>More importantly, layout is inherently recursive. In order to measure its own width, a layout view must measure all of its children first, which requires measuring grandchildren, and so on. If we were to do this on every update tick, it would perform poorly, or at least no better than the equivalent immediate mode UI. To avoid this, StardewUI makes use of a common technique called dirty checking.</p> <p>Separate measure and layout passes allow us to do useful things that single-pass layouts tend to have trouble with\u2014for example, aligning content to both the left and right sides of a container, where the main content stretches to fill the remaining width:</p> Navigation Main Content Info Page 1 Contents of the current page; an item grid or list, NPC profile, options form, etc. Additional sidebar content Page 2 Page 3 <p>This layout is only possible with a measure pass, as we need to know the width of both the Navigation and Info columns (lanes) before it is possible to lay out the Main Content lane. In fact, this requires two measure passes (called initial and deferred) although that is an implementation detail of the layout view and not all layouts require a deferred pass.</p>"},{"location":"concepts/#dirty-checking","title":"Dirty Checking","text":"<p>Rerunning layout on every tick would be expensive, so in order to avoid doing this, StardewUI\u2014like many frameworks\u2014employs a form of dirty-checking. This is sometimes referred to as \"invalidation\", and while there are some subtle differences between invalidation and dirty-checking, they are close enough to be considered the same for the purposes of this section.</p> <p>Invalidation/dirty checking is the process of keeping track of what state was modified (since the last completed layout) in addition to a view's current state. \"State\" is complex and view-specific but can generally be described as the combination of:</p> <ol> <li>Details of the layout request, e.g. the previous limits compared to new limits</li> <li>Values of any layout-affecting properties, such as the <code>LayoutParameters</code> (obviously) but also padding, margins, current text of a label<sup>1</sup>, current value of a slider, etc.</li> <li>The dirty state of any and all child views.</li> </ol> <p>Layout always proceeds from the top down, but dirty-checking cascades from the bottom up. This might seem like a bad thing\u2014yes, a change at any level of the view hierarchy means that the entire layout must be done again\u2014but in fact it is what allows large parts of the layout, and often the entire layout, to be skipped in each pass, reducing the \"typical\" workload to almost nothing. This is the basic principle behind a retained mode (as opposed to immediate-mode) UI.</p> <p>Consider our earlier example and suppose the slider value was changed. Because the slider is dirty, and that dirtiness cascades upward, the entire Menu Lane is effectively dirty. However:</p> <ol> <li>When the <code>Banner: Settings</code> view is measured, it sees that the limits have not changed, and since the banner itself is not dirty, it does not need to perform layout again; it can reuse the same layout as last frame.</li> <li>The <code>Frame: Border</code> is part of the dirty cascade, so it has to perform layout again. However, <code>Label: Speed</code> and <code>Lane: Row 1</code> end up in the same state as the banner; they are not dirty, and their limits are the same as before, so they skip layout.</li> <li>We then get to <code>Lane: Row 2</code>, which is dirty, and <code>Slider</code>, which of course requires new layout, although <code>Label: Speed multiplier</code> can also be skipped for the same reason as previous views.</li> </ol> <p>Thus in the end, we have only actually performed layout on 4 out of the 10 total views; the Menu Lane, Border Frame, Row 2 Lane and Slider. The larger and more complex a view tree gets, the more is saved by this branch-elimination; in a tree of 100 views, a single dirty property may involve fewer than 10 views in the layout update.</p> <p>This same logic can also apply if the change happens at the top level. For example, consider if <code>Lane: Menu</code> had its width increased (perhaps because we change the title of the \"Settings\" banner to something much longer), but <code>Frame: Border</code> is configured with a fixed width or maximum width. When layout is triggered, the entire <code>Frame: Border</code> can be skipped because its limit width hasn't changed and therefore the change in available width cannot affect it.</p> <p>If you ever run into a poorly-performing UI, use this knowledge to help. If you are frequently changing some content and that is causing slowdowns due to frequent layouts, you may be able to mitigate most of the impact by using a fixed-width container somewhere in between.</p>"},{"location":"concepts/#data-binding","title":"Data Binding","text":"<p>A term from the heyday of visual database tools like Microsoft Access, the phrase Data Binding in modern usage refers to the ability of a UI framework to keep the state of the UI in sync with some data that is not part of the UI.</p> <p>Most real-world UI is not static. For example, you have a label that is supposed to display the name of some item. But which item?</p> <pre><code>&lt;label text=\"Parsnip\" /&gt;\n</code></pre> <p>isn't very helpful unless you know the item is always going to be a Parsnip. When you build your own UI from scratch using <code>SpriteBatch</code>, you tell it exactly what text to display on every <code>draw</code> call. However, when you write StarML and use the Framework API to display it, you don't have access to the actual <code>Label</code> instance, nor any ability to set its <code>Text</code>. How do we make this display the name of any item, not just static text?</p> <p>The answer is a data binding:</p> <pre><code>&lt;label text={ItemName} /&gt;\n</code></pre> <p>Along with a model such as:</p> <pre><code>public class ViewData\n{\n    public string ItemName { get; set; } = \"\";\n}\n</code></pre> <p>The full details are covered in the StarML guide; at a conceptual level, what matters is that StardewUI does the synchronization work for you. You don't control the <code>Label</code> directly, but you don't need to, because you have bound its text to a model (<code>ViewData</code>) that you do control. <code>ViewData</code> is part of your mod.</p> <p>This style of UI development favors the \"Model-View\" family \u2013 informally, Model-View-Whatever.</p> <p>But, there's a catch... if you want these data bindings to be more than a one-shot deal\u2014that is, if you want to be able to change the <code>ItemName</code> and see the changes show up immediately in the UI\u2014then you need to implement INotifyPropertyChanged (aka: \"INPC\"). Doing so can be very tedious, so head on over to Binding Context for helpful tips and shortcuts to make it much faster and easier.</p> <ol> <li> <p>Whether or not a particular property truly alters the layout is not always certain; for example, a label that is constrained to 1 line may have no cascading effect if its parent is a horizontally-stretched or fixed vertical lane. However, the relationships in an arbitrary hierarchy can be surprisingly complex\u2014for example, a vertical lane that is horizontally content-sized might be affected by a change to the text of an inner label, but only if it is the longest label or becomes the longest label, etc.</p> <p>Because the effects can be so unpredictable, attempting to check whether layout will be affected can be almost as expensive and far more complex and bug-prone than simply redoing the layout; therefore, StardewUI generally just assumes that any dirty property means a new layout is required.\u00a0\u21a9</p> </li> </ol>"},{"location":"framework/","title":"UI Framework","text":""},{"location":"framework/binding-context/","title":"Binding Context","text":""},{"location":"framework/binding-context/#redirects","title":"Redirects","text":""},{"location":"framework/starml/","title":"Stardew Markup Language (StarML)","text":"<p>StarML is the markup language used by the UI Framework. It is an HTML-like syntax based on a tree of elements, each corresponding to a view.</p> <p>It shares many traits with Angular templates, particularly an enhanced set of attributes that perform data binding and other special functions.</p> <p>Example</p> <pre><code>&lt;frame layout=\"850px 500px\"\n       background={@Mods/StardewUI/Sprites/MenuBackground}\n       border={@Mods/StardewUI/Sprites/MenuBorder}\n       border-thickness=\"36, 36, 40, 36\"&gt;\n    &lt;lane layout=\"stretch content\" orientation=\"vertical\"&gt;\n        &lt;label font=\"dialogue\" text=\"Hello from StardewUI!\" /&gt;\n        &lt;label text={IntroParagraph} /&gt;\n        &lt;textinput layout=\"200px content\" text={&lt;&gt;FarmerName} /&gt;\n        &lt;image layout=\"400px 100px\" sprite={@Mods/TestMod/Sprites/Hello} /&gt;\n        &lt;button text=\"Launch\" click=|LaunchCoolFeature(\"now\")| /&gt;\n    &lt;/lane&gt;\n&lt;/frame&gt;\n</code></pre>"},{"location":"framework/starml/#elements","title":"Elements","text":"<p>As with most markup languages, StarML is built around elements. An element is:</p> <ul> <li>A single tag</li> <li>with any number of distinct attributes</li> <li>and zero or more children.</li> </ul> <p>Every StarML element corresponds to a View, whose type is decided by its tag; every attribute corresponds to a property or event on that view (except structural attributes), and child elements correspond to the view's child views.</p> <p>Like HTML and XML, elements can either have an explicit closing tag, or be self-closing:</p> <p>Opening/Closing Tags</p> <pre><code>&lt;frame layout=\"50px 50px\"&gt;\n    ...\n&lt;/frame&gt;\n</code></pre> <p>Self-Closing Tag</p> <pre><code>&lt;label text=\"Hello\" /&gt;\n</code></pre> <p>There are no strict rules around the use of opening/closing vs. self-closing tags\u2014any element can be written using either style. The difference is that self-closing tags cannot have any children; thus tend to be used for \"simple\" views such as <code>&lt;label /&gt;</code> and <code>&lt;image /&gt;</code>, while open tags are used for layout views like <code>&lt;frame&gt;</code>, <code>&lt;lane&gt;</code> and <code>&lt;panel&gt;</code>.</p> <p> Because the UI Framework is an abstraction over regular Views, it will not enable you to do anything with a View that would be impossible or prohibited in the Core Library, such as add children to a non-layout view.</p>"},{"location":"framework/starml/#tags","title":"Tags","text":"<p>A tag is anything between a pair of angle brackets <code>&lt;  &gt;</code>, one of:</p> <ul> <li>An opening tag: <code>&lt;panel&gt;</code></li> <li>A closing tag: <code>&lt;/panel&gt;</code></li> <li>A self-closing tag: <code>&lt;panel /&gt;</code>.</li> </ul> <p>While the term \"tag\" may sometimes be used synonymously with \"element\", tags refer more narrowly to the specific markup above, i.e. not including any attributes or children.</p> <p>In StarML, tags are not arbitrary; except for <code>&lt;include&gt;</code>, the tag defines the specific type of view that is to be created, which in turn determines what attributes are allowed and how many children it is allowed to have.</p> <p>These are the standard tags available in the UI framework:</p> <p>Note</p> <p>The full list of tags currently supported can always be found in the ViewFactory source.</p> Tag View/Behavior Description <code>&lt;banner&gt;</code> Banner Displays a banner, aka \"scroll\", using a cartoonish font. Background optional. <code>&lt;button&gt;</code> Button Simple raised button with optional hover effect. <code>&lt;checkbox&gt;</code> Checkbox Checkbox with optional clickable label. <code>&lt;digits&gt;</code> Tiny Number Label Displays a number in extra-small font; used for item quantities. <code>&lt;dropdown&gt;</code> Drop-Down List Select from a list of options. <code>&lt;expander&gt;</code> Expander Can be clicked to show or hide more content. <code>&lt;frame&gt;</code> Frame Draws a border and/or background around another view. <code>&lt;grid&gt;</code> Grid Uniform grid layout using either fixed size per item or fixed number of items per row/column. <code>&lt;image&gt;</code> Image Displays one image using a variety of scaling and fit options. <code>&lt;include&gt;</code> Included View Insert a different StarML view in this position, using its asset <code>name</code> to load the content. <code>&lt;label&gt;</code> Label Displays single- or multi-line text using a standard <code>SpriteFont</code>. <code>&lt;lane&gt;</code> Lane Arranges other views along one axis, either horizontal (left to right) or vertical (top to bottom). <code>&lt;marquee&gt;</code> Marquee Animates scrolling text or other content horizontally; named after the HTML Marquee. <code>&lt;panel&gt;</code> Panel Displays all children as layers ordered by z-index. Positions can be adjusted using margins. <code>&lt;scrollable&gt;</code> Scrollable View Shows scroll bars and arrows when content is too large to fit. <code>&lt;slider&gt;</code> Slider A numeric slider that can be moved between a minimum and maximum range. <code>&lt;spacer&gt;</code> Spacer Draws nothing, but takes up space in the layout; used to \"push\" siblings to one side. <code>&lt;textinput&gt;</code> Text Input Input box for entering text; includes on-screen keyboard when activated by gamepad."},{"location":"framework/starml/#attributes","title":"Attributes","text":"<p>Tags define what view will be created; attributes define how it will look and behave, and specifically its properties and events.</p> <p>An attribute is any string appearing inside a tag that has the form <code>attr=value</code>, where <code>value</code> is one of the supported flavors, such as a quoted string like <code>text=\"Hello\"</code> or data binding expression like <code>text={HelloMessage}</code>.</p> <p>There are also structural attributes which are a separate topic.</p>"},{"location":"framework/starml/#common-attributes","title":"Common Attributes","text":"<p>Note</p> <p>These are the attributes common to all types of views (tags). Specific views usually have additional properties. Refer to the standard views documentation for details.</p> <p>In StarML, the name of an attribute is always the kebab-case version of the property name, e.g. <code>HorizontalContentAlignment</code> becomes <code>horizontal-content-alignment</code>.</p> Attribute\u00a0 Direction\u00a0(1) Type\u00a0(2) Explanation <code>actual-bounds</code> Out <code>Bounds</code> True outer bounds of the view relative to its parent, including margins. <code>border-size</code> Out <code>Vector2</code> Size of the view's content plus padding and border width. <code>content-bounds</code> Out <code>Bounds</code> True bounds of the view's content relative to its parent, excluding margins. <code>content-size</code> Out <code>Vector2</code> Size of the view's content, not including padding, borders or margins. <code>draggable</code> In/Out <code>bool</code> Allows this view to receive drag events (<code>drag</code>, <code>drag-start</code> and <code>drag-end</code>). <code>focusable</code> In/Out <code>bool</code> Allows this view to receive focus, or \"snap\", when using a gamepad. Automatically enabled for most interactive elements like <code>button</code> or <code>dropdown</code>. <code>inner-size</code> Out <code>Vector2</code> Size of the view's content and padding, excluding borders and margins. <code>layout</code> In/Out <code>LayoutParameters</code> The intended width and height. See conversions for allowed values. <code>margin</code> In/Out <code>Edges</code> Pixel sizes for whitespace outside the border/background. <code>name</code> In/Out <code>string</code> For <code>&lt;include&gt;</code> elements, the view's asset name; for all other elements, a user-defined name used mainly for logging and troubleshooting. <code>outer-size</code> Out <code>Bounds</code> Total layout size occupied by the element, including padding, borders and margins. <code>padding</code> In/Out <code>Edges</code> Pixel sizes for whitespace inside the border/background. <code>pointer-events-enabled</code> In/Out <code>bool</code> Can be set to <code>false</code> to prevent receiving clicks, mouseovers, etc. Use when a transparent view is drawn on top of an interactive view. <code>scroll-with-children</code> In/Out <code>Orientation</code> Forces the entire view to be visible when navigating in the specified direction. See the ScrollableView documentation for details. <code>tags</code> In/Out <code>Tags</code> Allows arbitrary data to be associated with the view. Not supported in StarML yet - may be supported in the future. <code>tooltip</code> In/Out <code>string</code> Tooltip to show when hovered with the mouse, or focused on via game controller. <code>visibility</code> In/Out <code>Visibility</code> Whether to show or hide the view; hiding does not remove it from the layout, use <code>*if</code> for that. <code>z-index</code> In/Out <code>int</code> Drawing order within the parent; higher indices are drawn later (on top). <ol> <li> <p>In/Out properties can accept any directional binding modifier; Out properties are read-only and can only be used to write to the model, e.g. if you need to receive the view's actual pixel size after a layout.</p> <p>Attempting to bind an <code>Out</code> property without the <code>&gt;</code> modifier, or attempting to assign it a literal value with a <code>=\"value\"</code> type attribute, will cause it to fail.</p> </li> <li> <p>StardewUI's views will often have property types that can't be carried across the API boundary due to current limitations on SMAPI and its version of Pintail.</p> <p>To help you through this, automatic conversions to and from other common types, such as tuples and XNA/MonoGame structures, are often provided if you want to bind one to your model and would rather not make everything a <code>string</code>.</p> <p>Note that some conversions may be lossy, i.e. if there is a difference in numeric precision.</p> </li> </ol>"},{"location":"framework/starml/#structural-attributes","title":"Structural Attributes","text":"<p>Structural attributes look like regular attributes, but with a <code>*</code> prefix. Instead of binding to properties or events, they control aspects of how the view tree is constructed.</p> Attribute\u00a0 Expected Type Description <code>*case</code> Any Removes the element unless the value is equal to the most recent <code>*switch</code>. The types of <code>*switch</code> and <code>*case</code> must either match exactly or be convertible. <code>*context</code> Any Changes the context that all child nodes bind to; used for heavily-nested data models. <code>*if</code> <code>bool</code> Removes the element unless the specified condition is met. <code>*repeat</code> <code>IEnumerable</code> Repeats the element over a collection, creating a new view for every item and setting its context to that item. Applies to both regular and structural attributes; e.g. if <code>*repeat</code> and <code>*if</code> are both specified, then <code>*repeat</code> applies first. <code>*switch</code> Any Sets the object that any subsequent <code>*case</code> attributes must match in order for their elements to show."},{"location":"framework/starml/#events","title":"Events","text":"<p>Event attributes look similar to property attributes, but deal specifically with .NET events raised by views. More generally, they are one of the two ways it is possible for the UI to communicate something back to your mod (the other being output/two-way bindings).</p> <p>While some UI might be purely informational (e.g. a tooltip or HUD), any interactive UI will probably involve one or more event bindings.</p> <p>Bindings for events use a specific flavor, where the handler and its arguments are enclosed in a pair of pipes (<code>|</code>):</p> <pre><code>&lt;image click=|PlantCrops(\"corn\", ^Quantity, $Button)| /&gt;\n</code></pre> <p>To experienced C# programmers, this may look like an ordinary method call, but it isn't. Event bindings are a powerful and complex feature, and reading the documentation on them is strongly recommended before using them.</p> <p>Note</p> <p>The events described below are the events common to all types of views (tags). Specific views may have additional events. Refer to the standard views documentation for details.</p> <p>In StarML, the name of an attribute is always the kebab-case version of the event name, e.g. <code>LeftClick</code> becomes <code>left-click</code>.</p> Event\u00a0 Arguments\u00a0Type\u00a0(1) Condition <code>click</code> <code>ClickEventArgs</code> Any mouse/gamepad button clicked. <code>drag</code> <code>PointerEventArgs</code> Ongoing drag operation; mouse was moved while button is still held. <code>drag-end</code> <code>PointerEventArgs</code> End of a drag operation, mouse button was released. <code>drag-start</code> <code>PointerEventArgs</code> First frame of a drag operation. <code>left-click</code> <code>ClickEventArgs</code> Left mouse button or controller A was pressed. <code>pointer-enter</code> <code>PointerEventArgs</code> Cursor just moved inside the view's bounds. <code>pointer-leave</code> <code>PointerEventArgs</code> Cursor just moved outside the view's bounds. <code>right-click</code> <code>ClickEventArgs</code> Right mouse button or controller X was pressed. <code>wheel</code> <code>WheelEventArgs</code> Mouse wheel movement was detected. <ol> <li>Provided here as a reference for looking up the properties in Events Source. You don't consume these types directly in your event handlers; consult the Event Docs for details on how to set up handlers.</li> </ol>"},{"location":"framework/starml/#attribute-flavors","title":"Attribute Flavors","text":"<p>Regular HTML uses quoted attributes; to support the more complex behaviors where the attribute value should not be interpreted literally (as in, the exact value inside the quotes), StarML uses different \"flavors\" of attributes using different punctuation.</p> <p>Bindings are not tokens</p> <p>Those accustomed to Content Patcher Tokens may need to unlearn certain habits, because what goes on behind the scenes with StarML is far more complicated than string replacement. If you attempt to write \"tokens\" of the form <code>attr=\"A {{value}} B\"</code>, you are going to be disappointed.</p> Format Meaning <code>attr=\"value\"</code> The literal (converted) value inside the quotes. <code>attr={PropertyName}</code> The current value of the specified context property. <code>attr={@AssetName}</code> The current content of the named asset. <code>attr=|Handler(Arg1, ...)|</code> Call the specified context method, with the specified arguments; only valid for event attributes. Note <p>Double-braces (<code>{{</code> and <code>}}</code>) are allowed in place of single braces, for those heavily accustomed to Content Patcher syntax and JSON tokens in general, but are not recommended due to the inconsistency with other attributes and reduced readability.</p>"},{"location":"framework/starml/#binding-modifiers","title":"Binding Modifiers","text":"<p>In addition to the different attribute flavors,  context binding attributes\u2014that is, those of the form <code>attr={PropertyName}</code>\u2014can use modifier prefixes to either redirect to a different context or change the direction of synchronization between context and view.</p> <p>These modifiers work only with context property and event bindings; they cannot be used on literal attributes or assets.</p> Modifier Example Effect <code>^</code> <code>{^Prop}</code> Binds to the parent context instead of the current context. Multiple <code>^</code> characters can be appended to go farther up, e.g. <code>^^^Prop</code>. <code>~</code> <code>{~Foo.Prop}</code> Binds to the typed ancestor instead of the current context. <code>&lt;</code> <code>{&lt;Prop}</code> Specifies an input binding, where the view receives its value from the model but does not write back. This is the default behavior when no modifier is used, and can generally be omitted. <code>&gt;</code> <code>{&gt;Prop}</code> Specifies an output binding, where the view writes its value to the model but does not read back. <code>&lt;&gt;</code> <code>{&lt;&gt;Prop}</code> Specifies an in/out binding, where the view both receives its value from the model and writes back to the model. <p>Tip</p> <p>Context modifiers can be combined with direction modifiers, but order matters; the direction must come first. You can write <code>{&lt;&gt;^^Prop}</code> or <code>{&gt;~Foo.Prop}</code>, but not <code>{^^&lt;&gt;Prop}</code> or <code>{~&gt;Foo.Prop}</code>.</p>"},{"location":"framework/starml/#type-conversions","title":"Type Conversions","text":"<p>In the SMAPI world, integrations between mods, including framework mods, are accomplished by duck typing, specifically through the Pintail library. This is a highly effective system for backward-compatibility and in some cases forward-compatibility; however, it presents many challenges for a UI library that uses many complex types.</p> <p>Many attribute types like <code>Bounds</code> and <code>Edges</code> simply can't be transmitted across the API boundary, even if you copy their definitions. Interface types such as <code>IView</code> are far too complex to copy over. StardewUI doesn't want you to have to deal with these issues on a one-off basis. Instead, it has a highly integrated system of type conversions: regardless of the actual, real type of a view's property or event argument, it can be assigned or bound to any property with a convertible type.</p> <p>In the table below, the String Format is what you can put in a literal attribute or a <code>string</code> typed context property; Converts From can be used with input bindings and Converts To can be used with output bindings or event arguments. For two-way bindings, the type must either be <code>string</code> or be in both the \"from\" and \"to\" lists.</p> <p>Note</p> <p>All primitive types (numeric and <code>bool</code>) can be converted from their string representation, and are not shown explicitly in the conversion table. All types can also be converted to a string, though whether or not the string is useful depends on its <code>ToString()</code> implementation.</p> <p> indicates a possible loss of numeric precision.</p> Type String Format Converts From Converts To Any <code>enum</code> (Field Name) N/A N/A <code>Point</code> <code>\"x, y\"</code> N/A N/A <code>Vector2</code> <code>\"x, y\"</code> N/A N/A <code>Rectangle</code> <code>\"x, y, width, height\"</code> N/A N/A <code>LayoutParameters</code> <code>\"&lt;Length&gt;\"</code>\u00a0(1) N/A N/A <code>\"&lt;Width&gt; &lt;Height&gt;\"</code> <code>Length</code> <code>\"&lt;num&gt;px\"</code> (2) N/A N/A <code>\"&lt;num&gt;%\"</code> (3) <code>\"content\"</code> (4) <code>\"stretch\"</code> (5) <code>Edges</code> <code>\"left, right, top, bottom\"</code> <code>Tuple&lt;int, int, int, int&gt;</code> <code>Tuple&lt;int, int, int, int&gt;</code> <code>Vector4</code> <code>Vector4</code> <code>int</code> <code>Point</code> <code>Tuple&lt;int, int&gt;</code> <code>Vector2</code> <code>Tuple&lt;Point, Point&gt;</code> <code>Tuple&lt;Vector2, Vector2&gt;</code> <code>Bounds</code> N/A N/A <code>Tuple&lt;float, float, float, float&gt;</code> <code>Tuple&lt;Vector2, Vector2&gt;</code> <code>Vector4</code> <code>Rectangle</code> <code>Color</code> <code>\"#rgb\"</code> N/A N/A <code>\"#rgba\"</code> <code>\"#rrggbb\"</code> <code>\"#rrggbbaa\"</code> <code>Sprite</code> (9) N/A <code>Texture2D</code> N/A <code>Tuple&lt;Texture2D, Rectangle&gt;</code> <code>ParsedItemData</code> <code>SpriteFont</code> <code>\"dialogue\"</code> (6) N/A N/A <code>\"small\"</code> (7) <code>\"tiny\"</code> (8) <code>GridItemLayout</code> <code>\"count: n\"</code> (10) N/A N/A <code>\"length: n\"</code> (11) <ol> <li>Applies the same value to both the <code>Width</code> and <code>Height</code>. See <code>Length</code> conversions below for what values are allowed for <code>&lt;Length&gt;</code>, <code>&lt;Width&gt;</code> or <code>&lt;Height&gt;</code>.</li> <li>Specifies an exact value in pixels, e.g. <code>100px</code>.</li> <li>Percentage of the container's available width or height, e.g. <code>50%</code>.</li> <li>As wide/tall as the content wants itself to be, up to the available container size.</li> <li>Use the entire width/height available, after any siblings that are not stretched.</li> <li>Reference to <code>Game1.dialogueFont</code></li> <li>Reference to <code>Game1.smallFont</code></li> <li>Reference to <code>Game1.tinyFont</code></li> <li>Sprites can be bound to model properties, but should only be done for sprites that must be dynamic. In the majority of cases, you should use sprite assets instead.</li> <li><code>n</code> is any positive integer; lays out the grid using n items per row/column and adjusts their size accordingly.</li> <li><code>n</code> is any positive integer; lays out the grid using a fixed width/height of <code>n</code> per item, and wraps to the next row/column when reaching the end.</li> </ol> <p>If a type shows \"N/A\" for conversions, that means no conversion is available, either because it is not meant to be used in that scenario, or because it is already a shared type. Shared types such as any of the XNA/MonoGame types can be used directly in your model and therefore don't require any conversions, except from <code>string</code> to be used in literal attributes.</p> <p>Unfortunately, allowing mods to arbitrarily extend this list would be a chicken-egg problem: you need direct access to the destination type in order to implement a converter. However, if anything important is missing, feel free to make a request or a contribution (writing a converter is usually very simple, often a single line of code).</p>"},{"location":"framework/starml/#children","title":"Children","text":"<p>In StarML\u2014as in HTML or XML\u2014an element's children are any tags appearing between the parent element's opening and closing tags:</p> <p>Example</p> <pre><code>&lt;lane&gt;\n    &lt;label text=\"Title\" /&gt;\n    &lt;frame&gt;\n        &lt;label text=\"Content\" /&gt;\n    &lt;/frame&gt;\n&lt;/lane&gt;\n</code></pre> <p>In the above example:</p> <ul> <li><code>&lt;label text=\"Title\" /&gt;</code> and <code>&lt;frame&gt;</code> are children of the <code>&lt;lane&gt;</code></li> <li><code>&lt;label text=\"Content\"</code> is a child of the <code>&lt;frame&gt;</code></li> </ul> <p>In general, only layout views can have children; attempting to add children to any other view type will cause an error.</p> <p>Children can only be added to elements with separate opening and closing tags, e.g. <code>&lt;lane&gt;...&lt;/lane&gt;</code>. Any self-closing tag, even if it corresponds to a layout view, cannot contain children, because a self-closing tag cannot be paired with a regular closing tag; just as with HTML or XML, <code>&lt;lane/&gt;...&lt;/lane&gt;</code> is simply invalid StarML and will fail to parse.</p> <p>Because of these constraints, all documentation and examples on this site use opening/closing tags for layout views, and self-closing tags for other views. While this is not a requirement for valid StarML, it is recommended that you do the same in order to avoid confusion and lower the chances of creating invalid markup.</p>"},{"location":"framework/starml/#child-limits","title":"Child Limits","text":"<p>Some layout views can have only one child, for example frames and scrollables. That means the following is invalid markup:</p> <p>Failure</p> <pre><code>&lt;frame&gt;\n    &lt;label text=\"Item 1\" /&gt;\n    &lt;label text=\"Item 2\" /&gt;\n&lt;/frame&gt;\n</code></pre> <p>This will parse, but will either fail to display at all or fail to display correctly, because the actual frame view only has a single <code>Content</code> view, not a list of views like a lane or panel.</p> <p>However, this rule applies only to the constructed view, not the markup itself. If only one of the children can actually display at a time, then there is no problem.</p> <p>Risky</p> <pre><code>&lt;frame&gt;\n    &lt;label *if={Item1Visible} text=\"Item 1\" /&gt;\n    &lt;label *if={Item2Visible} text=\"Item 2\" /&gt;\n&lt;/frame&gt;\n</code></pre> <p>This is a \"maybe\" because, while you might personally know \u2013 or expect \u2013 that <code>Item1Visible</code> and <code>Item2Visible</code> cannot both be <code>true</code> at the same time, the framework itself does not know that and cannot enforce it, and doing it this way could cause it to fail when you least expect it, e.g. long after your mod has been released and been downloaded several times.</p> <p>A better way is to use <code>*switch</code>:</p> <p>Success</p> <pre><code>&lt;frame *switch={VisibleItem}&gt;\n    &lt;label *case=\"Item1\" text=\"Item 1\" /&gt;\n    &lt;label *case=\"Item2\" text=\"Item 2\" /&gt;\n&lt;/frame&gt;\n</code></pre> <p>This version cannot fail because <code>VisibleItem</code> cannot be both <code>Item1</code> and <code>Item2</code> at the same time. In other words, it is always OK to have multiple child nodes underneath a single-view layout, if all of those nodes have a distinct <code>*case</code>. Otherwise, there is the possibility of failure.</p>"},{"location":"framework/starml/#why-not-html","title":"Why not HTML?","text":"<p>Some web frameworks, like Vue, are a subset of HTML; their templates are syntactically valid HTML, constructed in such a way that any special behavior can be understood using special tags, attributes with unusual but valid prefixes like <code>:class</code>, and so on. So, why not simply pull in an HTML (or XHTML) parser and use that?</p> <p>This went through careful consideration but ultimately seemed to have more negatives than positives. The potential positives:</p> <ul> <li>Several preexisting parsers are available for .NET;</li> <li>Common editors (Visual Studio Code, Notepad++, etc.) provide built-in syntax highlighting and validation;</li> <li>Already familiar to anyone with web development experience.</li> </ul> <p>The negatives:</p> <ul> <li>Using a third-party parser (or any third-party library) in a SMAPI environment is risky, and most parsers are not totally optimized for memory and speed.</li> <li>Common editors provide built-in syntax highlighting and validation that could be misleading given the real constraints of a Stardew UI. For example, interpolations like <code>attr=\"{value1} {value2}\"</code> are valid HTML but not actually supported.</li> <li>Prior web development experience only helps through the shallowest part of the learning curve, not with binding/event attributes, model design, asset organization, etc.</li> <li>If all attributes are quoted, then character escaping becomes a more significant issue, especially for literal expressions; imagine documents full of <code></code>.</li> <li>An HTML parser only breaks the raw text down into stringly-typed elements and attributes; StardewUI would then need to do a second round of parsing (i.e. twice as much work) on all the tags and attribute values to determine which attributes are standard vs. structural, which values are literals vs. bindings vs. events, determine all the property names and types involved in an event handler, and so on.</li> <li>The actual runtime model (widget tree) is not comparable to an HTML DOM; does not understand unknown tags or standard HTML tags, does not distinguish between block/inline/other styles, and so on. As an abstraction over native UI, the inner workings are more like Qt or Android than a web browser; therefore, an \"it's just HTML\" approach would eventually end up causing more friction and confusion than a custom language.</li> </ul> <p>What about XML?</p> <p>An alternative would be something similar to XAML, but these have a way of getting out of control; consider, for example, a \"simple\" binding redirect in XAML:</p> <pre><code>&lt;Label Content=\"{Binding Path=DisplayName, RelativeSource={RelativeSource Mode=FindAncestor AncestorLevel=1}}\"/&gt;\n&lt;Label Content=\"{Binding Path=DisplayName, RelativeSource={RelativeSource Mode=FindAncestor AncestorType={x:Type Foo}}}\"/&gt;\n</code></pre> <p>Compare to a StarML context redirect:</p> <pre><code>&lt;label text={^DisplayName} /&gt;\n&lt;label text={~Foo.DisplayName} /&gt;\n</code></pre> <p>And this is without any binding modifiers which add even more noise to XAML.</p> <p>This is not intended as a slight against XAML, which is actually a very powerful and mature tool for cross-platform development and far better than most of the available alternatives. However, it reflects a different use case: backing an enormous framework (WPF) that is difficult to update once released, needs to scale to almost any imaginable UI scenario, and can expect a very high level of expertise from dev-users.</p> <p>It is precisely because XML is so extensible that XML-based languages become convoluted over time; they encourage a way of thinking wherein new features are designed to fit into the XML structure somehow, even if the existing syntax is already confusing, verbose or requires some separately-interpreted micro-grammar, instead of the alternative of making a tiny change to the parser to support a relatively simple addition, like the <code>&lt;&gt;</code> or <code>^</code> modifiers above.</p> <p>StardewUI is a mod, which means it is easy to change the parser, easy to roll out said updates, and has fewer users and UI scenarios to cover, so more effort can go into making easy things easy, instead of making nearly-impossible things possible. For scenarios that StarML can't cover, the Core Library is the escape hatch.</p>"},{"location":"framework/starml/#why-not-json","title":"Why not JSON?","text":"<p>In many ways, JSON is the lingua franca of Stardew modding; it is the notation used by every content pack, not only for Content Patcher but for every other framework out there. Why should StardewUI be different?</p> <p>While sharing some of the same concerns as HTML, such as double-parsing and character-escaping, it does route around other issues such as third-party libraries (Json.NET is technically third-party, but is already available in every SMAPI environment).</p> <p>To understand why it's not a good fit, we can take a look at what kind of structure might be required for a very simple view. In this example, we display a frame border, a single header line, and the names of a list of NPCs.</p> StarMLHypothetical JSON <pre><code>&lt;frame layout=\"800px content\"&gt;\n    &lt;lane orientation=\"vertical\"&gt;\n        &lt;label font=\"dialogue\" text=\"Header Text\" /&gt;\n        &lt;label *repeat={Npcs} text={DisplayName} /&gt;\n    &lt;/lane&gt;\n&lt;/frame&gt;\n</code></pre> <pre><code>{\n    \"Type\": \"Frame\",\n    \"Layout\": \"800px content\",\n    \"Children\": [\n        {\n            \"Type\": \"Lane\",\n            \"Orientation\": \"Vertical\",\n            \"Children\": [\n                {\n                    \"Type\": \"Label\",\n                    \"Font\": \"dialogue\",\n                    \"Text\": \"Header Text\"\n                },\n                {\n                    \"Type\": \"Repeat\",\n                    \"Collection\": \"{{Npcs}}\",\n                    \"Content\": {\n                        \"Type\": \"Label\",\n                        \"Text\": \"{{DisplayName}}\"\n                    }\n                }\n            ]\n        }\n    ]\n}\n</code></pre> <p>Notice how much longer, more verbose, and more indented the JSON version is? Now picture how it would look in a view that is 5 levels deep, or 10. This is also the best case scenario for syntax, assuming we make some negative tradeoffs on the parsing side and use <code>JObject</code> instead of any concrete type, which is what allows us to use dictionary-style attributes for <code>Orientation</code>, <code>Font</code> and so on instead of defining yet another <code>\"Attributes\": [...]</code> array with objects inside it.</p> <p>At scale, the JSON version becomes unreadable; it is difficult to look at this data and even understand what it is supposed to do in broad strokes, to say nothing of keeping track of which indentation level you're at, what the context is at that level, etc. JSON can be used to represent a syntax tree, but it is not very good at it (or any other tree).</p> <p>JSON is native to the web; the \"J\" stands for \"JavaScript\", and yet it is not used by any mainstream web frameworks for defining the UI. This is because, while JSON is a good format for data storage, a full user interface cannot be represented very efficiently as plain data; it is not what we call ergonomic. That is exactly the problem that markup languages like HTML evolved to solve, and why we see similar mechanisms continue to evolve organically in every domain from .NET to Qt to Rust.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>If you've made a Stardew mod before, then setting up StardewUI should be a snap; it's the same as any other SMAPI integration.</p>"},{"location":"getting-started/#installing-the-framework","title":"Installing the Framework","text":"<p>StardewUI is prerelease, so it isn't published on Nexus Mods or any other mod site yet.</p> <ol> <li>Download the latest release. Make sure you download the <code>StardewUI x.y.z.zip</code> file, not the source code.</li> <li>Open the .zip file and extract the <code>StardewUI</code> folder into your <code>Stardew Valley\\Mods</code> folder.</li> </ol> <p>The framework is now ready to use from your own mods.</p>"},{"location":"getting-started/#adding-the-api","title":"Adding the API","text":"<p>If this is your first time working with a framework mod, have a look at SMAPI's guide to using an API. The abridged version is:</p> <ol> <li>Download the entire <code>IViewEngine.cs</code> to somewhere in your mod's source directory. (You can right-click, \"Save link as...\" from this page.)</li> <li>From wherever you want to invoke the API\u2014typically <code>ModEntry.cs</code>\u2014add to the top of the file:     <pre><code>using StardewUI.Framework;\n</code></pre></li> <li>Declare a field for the API:     <pre><code>private IViewEngine viewEngine;\n</code></pre></li> <li>Obtain the API in a <code>GameLaunched</code> handler:     <pre><code>viewEngine = Helper.ModRegistry.GetApi&lt;IViewEngine&gt;(\"focustense.StardewUI\");\n</code></pre></li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>At this point, you don't have any views or other assets; in order to get an actual UI up and running, you'll need to:</p> <ol> <li>Decide on a directory where your views and other assets will live inside your mod. (1)</li> <li>Register your asset path(s) so that the framework can find them.</li> <li>Create a new view file using the <code>.sml</code> extension. See editor setup for recommended editors/configurations.</li> <li>Ensure that the asset will be copied to your mod output. In Visual Studio, the file properties should look as follows: <p></p> </li> <li>Author the view. See the StarML guide, or checkout the examples if you're feeling impatient.</li> <li>Use the <code>IViewEngine</code> API you added earlier to display the view.</li> </ol> <ol> <li>We recommend <code>assets/views</code> for views and <code>assets/sprites</code> for sprites to be consistent with the examples and reference guides, but you can use any location(s) you prefer.</li> </ol> <p>Note that steps 1-2 only need to be done one time. As long as you keep all your assets in one place (directory), then any new ones you add will be automatically picked up by the framework; no need to register every asset individually.</p> <p>That's it! Have fun creating great UIs.</p>"},{"location":"getting-started/adding-ui-assets/","title":"Adding UI Assets","text":"<p>StardewUI has its own asset system based on SMAPI's own content APIs but providing some additional features: convention-based registration and hot reload.</p>"},{"location":"getting-started/adding-ui-assets/#conventions","title":"Conventions","text":"<p>Assets are registered by convention in StardewUI. You only need to specify where your assets are located, and it handles the translation between file names and asset names for you.</p> <p>Suppose your mod looks as follows:</p> <p> ModName     assets        sprites           ui.json           ui.png        views           config.sml           gifts.sml     IViewEngine.cs     ModEntry.cs</p> <p>For now, don't worry about what the various files do; the important thing is that views are in the directory <code>assets/views</code>, and the asset prefix is a setting you provide. If you choose a prefix of <code>Mods/author.ModName/Views</code>, then the asset names for these assets will be:</p> <ul> <li><code>Mods/author.ModName/Views/Config</code></li> <li><code>Mods/author.ModName/Views/Gifts</code></li> </ul> <p>That is, without the <code>assets/views</code> path and without the <code>.sml</code> extension.</p>"},{"location":"getting-started/adding-ui-assets/#adding-views","title":"Adding Views","text":"<p>The actual \"UI\" in StardewUI is based on Views. When using the framework\u2014which this part of the guide is based on\u2014your views will be in the form of <code>.sml</code> (StarML) files.</p> <p>To create a view, simply create the <code>.sml</code> file in your desired location, such as the <code>assets/views/config.sml</code> used above. Refer to the StarML guide or examples for more info on authoring views, i.e. what the actual contents of the file should be.</p> <p>Important</p> <p>Like any other mod content asset, you need to make sure that it is deployed with your mod build; Visual Studio, VSCode, Rider, etc. do not automatically do this for you. To do this: - Set Build Action to \"Content\" - Set Copy to Output Directory to \"Copy always\" or \"Copy if newer\"</p> <p> </p> <p>If you are not using any standard IDE or cannot find these settings, then you must add them to the <code>.csproj</code> file, e.g.</p> <pre><code>&lt;ItemGroup&gt;\n  &lt;None Remove=\"assets\\views\\config.sml\" /&gt;\n&lt;/ItemGroup&gt;\n\n&lt;ItemGroup&gt;\n  &lt;Content Include=\"assets\\views\\config.sml\"&gt;\n    &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;\n  &lt;/Content&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <p>Once the physical files are set up, you can register the view folder \u2013 not the individual views \u2013 using the API:</p> <pre><code>viewEngine.RegisterViews(\"Mods/author.ModName/Views\", \"assets/views\");\n</code></pre> <p>That's it\u2014just a single line!</p>"},{"location":"getting-started/adding-ui-assets/#adding-sprites","title":"Adding Sprites","text":"<p>Stardew Valley's visuals, like those of most 2D games, are based around sprites. All of Stardew's image assets and most mod assets are in the form of \"sprite sheets\", more formally known as a texture atlas, in which a single image (i.e. <code>.png</code> file) contains many individual \"objects\", each occupying its own rectangular region.</p> <p>Neither Stardew nor SMAPI have an explicit concept of a sprite. Since StardewUI needs to deal quite heavily with sprites, it defines its own Sprite type, which includes not only the source image and rectangular region but also information pertaining to 9-slice scaling, which is how it is able to display elements such as frame borders and menu backgrounds without having them appear awkwardly stretched.</p> <p>A variety of useful UI sprites are already included in the UiSprites class, and each of these sprites is available to StarML via an asset binding of the form <code>@Mods/StardewUI/Sprites/{Name}</code>; for example, <code>@Mods/StardewUI/Sprites/CaretRight</code>. However, Stardew Valley has thousands of individual sprites, and if you want to use anything that's not in <code>UiSprites</code>, or any sprite that you've produced yourself, then you need to register it as an asset.</p> <p>You can accomplish this with model binding by providing a <code>Texture2D</code> or <code>Tuple&lt;Texture2D, Rectangle&gt;</code> property, as described in conversion reference, but the recommended way to deal with sprites is to register them with StardewUI.</p> <p>In addition to allowing them to be used as asset bindings, like the <code>UiSprites</code>, StardewUI will also handle any cache management and hot reload for registered sprites, ensuring that (a) the UI will never crash because of an invalid (disposed) texture and (b) hot reload works correctly, and any changes to the game content, such as seasonal themes, are reflected immediately in the UI, even the UI is already on the screen.</p> <p>The process is almost the same whether you intend to use vanilla assets or provide custom images/sprites in your mod. Sprites are registered by convention, similar to views:</p> <pre><code>viewEngine.RegisterSprites($\"Mods/author.ModName/Sprites\", \"assets/sprites\");\n</code></pre> <p>Continue reading for an explanation of what goes in <code>assets/sprites</code>.</p>"},{"location":"getting-started/adding-ui-assets/#vanilla-sprites","title":"Vanilla Sprites","text":"<p>If you intend to take many images from a single texture atlas (\"sprite sheet\") then it is convenient to declare them all in one place. StardewUI provides a simple JSON structure for doing so. Suppose we are interested in the icons of various buffs:</p> assets/sprites/buffs.json<pre><code>{\n    \"Texture\": \"LooseSprites/BuffsIcons\",\n    \"Sprites\": {\n        \"Fishing\": {\n            \"SourceRect\": \"16, 0, 16, 16\"\n        },\n        \"Mining\": {\n            \"SourceRect\": \"32, 0, 16, 16\"\n        },\n        \"MonsterMusk\": {\n            \"SourceRect\": \"0, 32, 16, 16\"\n        }\n    }\n}\n</code></pre> <p>This instructs StardewUI to use the <code>LooseSprites/BuffsIcons</code> texture as the source, and provides the rectangular regions (in the form <code>\"left, top, width, height\"</code>) of the individual sprites we want. It just so happens that these are all 16x16, but that will not necessarily always be the case; <code>LooseSprites/Cursors</code>, for example, is notorious for both its enormous size and its total irregularity.</p>"},{"location":"getting-started/adding-ui-assets/#nine-slicing","title":"Nine-Slicing","text":"<p>Another advantage of the JSON format is that you can specify 9-slice scaling options. Suppose we want to use this image as a background (note: all images in this section have been scaled up 8x for clarity):</p> <p></p> <p>The Cursors sheet doesn't have this exact size; what it has instead is:</p> <p></p> <p>If we simply stretched this image to an arbitrary size, we would not get a good result:</p> <p></p> <p>Instead, we distinguish between the image's borders, which are not meant to stretch, and the center or middle slices which can stretch in one or both directions:</p> <p></p> <p>What we get are nine slices:</p> Left Middle Right Top No Stretch Stretch Horizontal No Stretch Middle Stretch Vertical Stretch H + V Stretch Vertical Bottom No Stretch Stretch Horizontal No Stretch <p>In this specific case, it should be apparent that there are:</p> <ul> <li>2 border pixels on the left</li> <li>3 border pixels on top</li> <li>3 border pixels on the right</li> <li>2 border pixels on the bottom.</li> </ul> <p>To configure this in the JSON:</p> assets/sprites/cursors.json<pre><code>{\n    \"Texture\": \"LooseSprites/Cursors\",\n    \"Sprites\": {\n        \"SpecialBorder\": {\n            \"SourceRect\": \"129, 338, 7, 9\",\n            \"FixedEdges\": \"2, 3, 3, 2\",\n            \"Scale\": 4\n        }\n    }\n}\n</code></pre> <p>One additional property we've specified here is <code>Scale: 4</code>. This tells StardewUI to first scale uniformly by 4x, then do the 9-slicing. The reason for this is that the Cursors image is based on a 16x16 \"tile\" size, but menus and other UI are based on a 64x64 \"tile\" size. Compare the version without scale to the version with scale:</p> Unscaled Scaled <p>The unscaled version might look better in a web browser, but it will look strange in the game, appearing far too \"HD\" compared to the content around it and clashing with other UI.</p> <p>Apply scaling according to the reference size vs. actual screen size. If you are using sprites from <code>Maps/MenuTiles</code>, those are already designed for a 64x64 tile size and should not be scaled (no <code>Scale</code> field), only sliced (<code>FixedEdges</code> field).</p>"},{"location":"getting-started/adding-ui-assets/#custommodded-sprites","title":"Custom/Modded Sprites","text":"<p>If the sprites you want to use are your own sprites, designed specifically for your mod (i.e. not simply replacing a vanilla asset, in which case you should configure StardewUI with the vanilla sprite instead), then the configuration requires only a few small tweaks from vanilla:</p> <ol> <li>Place your <code>.png</code> and <code>.json</code> files in the same directory, and give them the same name, e.g. <code>assets/sprites/ui.png</code> and <code>assets/sprites/ui.json</code>.</li> <li> <p>Remove the \"Texture\" line from the JSON file, so that it only contains <code>Sprites</code>. For instance, as used in one of the examples:</p> assets/sprites/ui.json<pre><code>{\n    \"Sprites\": {\n        \"Checked\": {\n            \"SourceRect\": \"0, 0, 9, 9\",\n        },\n        \"Unchecked\": {\n            \"SourceRect\": \"9, 0, 9, 9\",\n        }\n    }\n}\n</code></pre> </li> </ol> <p>Aside from the addition of the <code>.png</code> file and the removal of the <code>Texture</code> field, it is exactly the same as a vanilla sprite.</p>"},{"location":"getting-started/adding-ui-assets/#referencing-sprites","title":"Referencing Sprites","text":"<p>When using JSON configuration, the primary asset is the Texture and JSON data itself. To reference an individual sprite, use the form: <code>{AssetPrefix}/{SpriteSheetName}:{SpriteName}</code>.</p> <p>For example, using the previous example of buff sprites, along with the modded sprites, we might end up with the following template:</p> <pre><code>&lt;frame background={@Mods/author.ModName/Sprites/Cursors:SpecialBorder}&gt;\n    &lt;image layout=\"36px 36px\" sprite={@Mods/author.ModName/Sprites/UI:Checked} /&gt;\n&lt;/frame&gt;\n</code></pre>"},{"location":"getting-started/displaying-ui/","title":"Displaying UI","text":"<p>Before you can display any UI, you'll need to have:</p> <ol> <li>Initialized the Framework API;</li> <li>Authored one or more StarML views and set them up to be deployed; and</li> <li>Registered the asset path of your view(s).</li> </ol> <p>Once all those steps are completed, it's time to bring that UI to life.</p>"},{"location":"getting-started/displaying-ui/#menus","title":"Menus","text":"<p>To create a menu from a StardewUI view, use the <code>CreateMenu</code> methods:</p> Menu From AssetMenu From Markup <pre><code>var context = new SomeViewModel(...);\nIClickableMenu menu = viewEngine.CreateMenuFromAsset(\n    \"Mods/authorName.ModName/Views/SomeView\",\n    context);\n</code></pre> <pre><code>var context = new SomeViewModel();\nstring markup =\n    @\"&lt;lane layout=\"\"500px content\"\" orientation=\"\"vertical\"\"&gt;\n        &lt;label font=\"\"dialogue\"\" text=\"\"Things\"\" /&gt;\n        &lt;label *repeat={Things} text={DisplayName} /&gt;\n    &lt;/lane&gt;\";\nIClickableMenu menu = viewEngine.CreateMenuFromMarkup(markup, context);\n</code></pre> <p>Where <code>Mods/authorName.ModName/Views/SomeView</code> is the concatenation of the view's asset prefix, e.g. <code>Mods/authorName.ModName/Views</code>, with the StarML file name/path, e.g. <code>SomeView</code> (excluding the <code>.sml</code> extension).</p> <p>Once created, the menu is shown the same way as a vanilla menu, e.g. by assigning it to <code>Game1.activeClickableMenu</code>, or as a child menu of another menu, or to <code>TitleMenu.subMenu</code>, and so on.</p> <p>Danger</p> <p>The <code>CreateMenuFromMarkup</code> method is only intended for testing, or for very unusual scenarios where the UI needs to be constructed completely on the fly and the combination of data bindings and structural attributes such as <code>*switch</code> and <code>*if</code> aren't sufficient, which should be rare.</p> <p>Programmatically-constructed StarML must be parsed every time the view is created and won't benefit from hot reload or from many of StardewUI's performance optimizations.</p> <p><code>CreateMenuFromAsset</code> is always the recommended entry point and should be used whenever possible.</p> <p>Several complete examples are provided in the test mod:</p> <pre><code>var context = new\n{\n    HeaderText = \"Example Menu Title\",\n    ItemData = ItemRegistry.GetData(\"(O)117\"),\n};\nGame1.activeClickableMenu = viewEngine.CreateMenuFromAsset(\n    \"Mods/focustense.StardewUITest/Views/TestView\",\n    context);\n</code></pre>"},{"location":"getting-started/displaying-ui/#hud","title":"HUD","text":"<p>The game's HUD \u2013 Heads Up Display \u2013 refers to the persistent UI that is drawn over top of the game world, such as the date/time widget, health/energy bars, and so on.</p>"},{"location":"getting-started/displaying-ui/#using-the-api","title":"Using the API","text":"<p>The recommended way to display HUD-style UI is to create a Drawable from StarML. The API for this is very similar to the menu API:</p> Drawable From AssetDrawable From Markup <pre><code>IViewDrawable drawable =\n    viewEngine.CreateDrawableFromAsset(\"Mods/authorName.ModName/Views/SomeView\");\ndrawable.Context = new SomeViewModel(...);\n// Optional, only needed if the view is not fixed-size\ndrawable.MaxSize = new(maxWidth, maxHeight);\n</code></pre> <pre><code>var context = new SomeViewModel();\nstring markup =\n    @\"&lt;lane layout=\"\"500px content\"\" orientation=\"\"vertical\"\"&gt;\n        &lt;label font=\"\"dialogue\"\" text=\"\"Things\"\" /&gt;\n        &lt;label *repeat={Things} text={DisplayName} /&gt;\n    &lt;/lane&gt;\";\nIViewDrawable drawable = viewEngine.CreateDrawableFromMarkup(markup);\ndrawable.Context = new SomeViewModel(...);\n// Optional, only needed if the view is not fixed-size\ndrawable.MaxSize = new(maxWidth, maxHeight);\n</code></pre> <p>Danger</p> <p>Avoid using the <code>CreateDrawableFromMarkup</code> variant in release builds for the same reasons described in menus.</p> <p><code>IViewDrawable</code> implements <code>IDisposable</code>. If you are done with an instance and never going to draw it again, make sure to call its <code>Dispose()</code> method. StardewUI will attempt to detect unreachable drawables and stop updating them, but this is less reliable and will take longer than a drawable that was disposed correctly, potentially degrading game performance over time.</p> <p>The test mod also has a simple HUD example:</p> <pre><code>private void ToggleHud()\n{\n    if (hudWidget is not null)\n    {\n        hudWidget.Dispose();\n        hudWidget = null;\n    }\n    else\n    {\n        hudWidget = viewEngine.CreateDrawableFromAsset(\n            \"Mods/focustense.StardewUITest/Views/Example-Hud\");\n        hudWidget.Context = new { Title = \"I'm a HUD!\" };\n    }\n}\n</code></pre>"},{"location":"getting-started/displaying-ui/#using-views-directly","title":"Using Views Directly","text":"<p>Advanced usage warning</p> <p>This section is provided for disambiguation, since there are more differences between the Core Library and Framework usage for HUD-style UI than there are for menus. If you aren't already using the Core Library to handle specialized scenarios or extend the framework, ignore this section and use the drawable API instead.</p> <p>When working with the core library, the <code>IViewDrawable</code> abstraction is not involved; instead, <code>IView</code> can be used directly with a <code>SpriteBatch</code>.</p> <p>A Fishing Sea uses this older method for its HUD:</p> <p>Example</p> <pre><code>internal sealed class ModEntry : Mod\n{\n    private IView? seedFishPreview;\n\n    public override void Entry(IModHelper helper)\n    {\n        seedFishPreview = new SeedFishInfoView();\n\n        helper.Events.Display.RenderedHud += Display_RenderedHud;\n    }\n\n    private void Display_RenderedHud(object? sender, RenderedHudEventArgs e)\n    {\n        seedFishPreview.Measure(new(500, 500));\n        var overlayBatch = new PropagatedSpriteBatch(\n            spriteBatch,\n            Transform.FromTranslation(new Vector2(0, 100))\n        );\n        SeedFishPreview.Draw(overlayBatch);\n    }\n}\n</code></pre> <p>The above is substantially simplified from the actual mod code for brevity. There are only 3 steps to the process:</p> <ol> <li>Create an <code>IView</code> or <code>IDrawable</code> instance and save it (do not recreate the view on every frame).</li> <li>Each frame, call its <code>Measure</code> method, providing the maximum width/height it should be allowed to use; the actual width/height may be smaller.</li> <li>After measuring\u2014usually immediately afterward\u2014Call the view's <code>Draw</code> method with the desired position.</li> </ol> <p>Important</p> <p>Unless the view is completely static (that is, neither its content nor its position ever changes), you must call <code>Measure</code> on every frame. This method is responsible for layout, and changes to a view's properties, such as the text of a label, will not be reflected until the next layout. Do not be concerned about frame performance; StardewUI is very careful to limit work to the parts that changed.</p>"},{"location":"getting-started/displaying-ui/#other-scenarios","title":"Other Scenarios","text":"<p>These are considered advanced usage and not recommended for StardewUI beginners; to learn more, head to the respective page:</p> <ul> <li>Overlays</li> </ul>"},{"location":"getting-started/editor-setup/","title":"Editor Setup","text":"<p>StardewUI doesn't require you to use any special editor, but StarML, like JSON or HTML, is much easier to write correctly when using an editor with syntax highlighting.</p> <p>Some editors may behave acceptably if told to treat <code>.sml</code> as either HTML or XML, but the results vary widely across editors.</p>"},{"location":"getting-started/editor-setup/#recommended-editors","title":"Recommended Editors","text":"<p>These are the editors with full support for StarML, provided as extensions.</p> <ul> <li>Visual Studio, using the StardewUI Extension. Best for C# developers on Windows.</li> <li>Visual Studio Code, using the vscode-starml extension.</li> </ul> <p>When using one of these editors with the corresponding extension installed, <code>.sml</code> (or <code>.starml</code>) files will be recognized as StarML and have correct highlighting for all types of syntax elements (tags, literal attributes, structural attributes, all the different attribute flavors).</p>"},{"location":"getting-started/editor-setup/#alternative-editors","title":"Alternative Editors","text":"<p>If you cannot use any of the recommended editors, then the following have been tested to have partial/incomplete highlighting:</p> <ul> <li>Notepad++ in XML mode (select \"XML\" from the \"Language\" menu after opening a <code>.sml</code> file).</li> </ul> <p>These options produce sane results that highlight the basic structure of the document correctly, but may struggle with certain aspects; for example, binding modifiers may be interpreted as tags or otherwise break the attribute highlighting.</p>"},{"location":"getting-started/hot-reload/","title":"Hot Reload","text":"<p>When using the recommended asset registration for views and sprites, StardewUI can watch for changes to asset files (<code>.sml</code>, <code>.png</code> and <code>json</code>) and update them immediately, even while the game is running and while the specific UI (menu, HUD, etc.) is open. This can be very useful for troubleshooting layout issues, making small tweaks toward a pixel-perfect UI, or simply using a playground for experimentation.</p>"},{"location":"getting-started/hot-reload/#enabling-hot-reload","title":"Enabling Hot Reload","text":"<p>Once you have a reference to the API, turning on hot reload is a single method call:</p> <pre><code>viewEngine.EnableHotReload();\n</code></pre> <p>A good place to do this is after the asset registrations, as in the Example Mod.</p> <p>For best results, it is recommended to turn off the game setting labeled \"Pause When Game Window Is Inactive\":</p> <p></p> <p>Disabling this setting forces the game to process update ticks even while you are working in a separate window\u2014such as your code editor. This gives you truly instant hot reload, without having to switch back to the game window.</p>"},{"location":"getting-started/hot-reload/#file-locations","title":"File Locations","text":"<p>Hot reload works on the mod assets; it does not know the original source of those assets.</p> <p>Important</p> <p>In order for hot reloading to work, make sure you are directly editing or copying your edits to the deployed files; that is, the file inside your <code>Stardew Valley\\Mods\\&lt;ModName&gt;</code> folder.</p>"},{"location":"getting-started/hot-reload/#performance","title":"Performance","text":"<p>When hot-reload is enabled, StardewUI must monitor your mod directory. While the overhead of doing so is generally low, having many mods do this at the same time(1) could cause lag/jank or other performance problems in game. To be polite to other modders, and players, it is recommended to turn off hot reload in the released version of your mod, since players will not be using the feature themselves.</p> <ol> <li>The Framework API is partially scoped to each mod using it, and Hot Reload is a per-mod setting.</li> </ol> <p>There are two ways to do this:</p> <ol> <li>Remove the call to <code>EnableHotReload()</code> before building your mod for release; or</li> <li> <p>Use conditional compilation. A simple and effective solution is to enable hot reloading in Debug mode only, as you will presumably be shipping the Release version.</p> <pre><code>#if DEBUG\n    viewEngine.EnableHotReload();\n#endif\n</code></pre> </li> </ol> <p>Conditional compilation is the recommended approach, as it is a permanent solution and avoids having hot-reloading accidentally enabled in a release build.</p>"},{"location":"library/","title":"Core Library","text":""},{"location":"library/overlays/","title":"Overlays","text":""},{"location":"library/standard-views/","title":"Standard Views","text":""},{"location":"library/standard-views/#layouts","title":"Layouts","text":""},{"location":"library/standard-views/#expander","title":"Expander","text":""},{"location":"library/standard-views/#frame","title":"Frame","text":""},{"location":"library/standard-views/#grid","title":"Grid","text":""},{"location":"library/standard-views/#lane","title":"Lane","text":""},{"location":"library/standard-views/#panel","title":"Panel","text":""},{"location":"library/standard-views/#scrollable-view","title":"Scrollable View","text":""},{"location":"library/standard-views/#widgets","title":"Widgets","text":""},{"location":"library/standard-views/#banner","title":"Banner","text":""},{"location":"library/standard-views/#button","title":"Button","text":""},{"location":"library/standard-views/#checkbox","title":"Checkbox","text":""},{"location":"library/standard-views/#drop-down-list","title":"Drop-Down List","text":""},{"location":"library/standard-views/#image","title":"Image","text":""},{"location":"library/standard-views/#label","title":"Label","text":""},{"location":"library/standard-views/#marquee","title":"Marquee","text":""},{"location":"library/standard-views/#slider","title":"Slider","text":""},{"location":"library/standard-views/#spacer","title":"Spacer","text":""},{"location":"library/standard-views/#text-input","title":"Text Input","text":""},{"location":"library/standard-views/#tiny-number-label","title":"Tiny Number Label","text":""}]}